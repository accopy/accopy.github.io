[{"title":"税务系统自动登录脚本","path":"/2025/01/11/税务系统自动登录脚本/","content":"前言许多店主需要登录税务系统开票，每次开票时都需手动填写登录信息，虽然安全性高，但步骤较为繁琐。由于我有多个账号需要开票，每次登录时都需填写不同的登录信息，十分麻烦，因此我打算编写一个自动登录的脚本。 准备下面以微软的Edge浏览器为例：在 Microsoft Edge 加载项扩展商店中搜索 篡改猴 下载并安装 新建脚本在 篡改猴 插件的管理面板中新建脚本并输入以下代码 ，按需求填写相应的账号、密码等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204let liancheng= &#123; name:&#x27;&#x27;, //插入按钮的名称 code:&#x27;&#x27;, //统一信用代码 phone:&#x27;&#x27;, //手机号 password:&#x27;&#x27; //密码 &#125;let lingrui= &#123; name:&#x27;&#x27;, //插入按钮的名称 code:&#x27;&#x27;, //统一信用代码 phone:&#x27;&#x27;, //手机号 password:&#x27;&#x27; //密码 &#125;//页面加载完成执行，获取进入登录页面的按钮，点击进入登录页面window.addEventListener( &quot;load&quot;, function () &#123; console.log(&quot;页面加载完成！&quot;); //登录表单页 let btn = document.querySelector(&quot;.loginBtn&quot;); //登录首页 if (btn) &#123; btn.click(); &#125; &#125;, false ); var formAuto = setInterval(() =&gt; &#123; let a = document.querySelector( &#x27;[placeholder=&quot;统一社会信用代码/纳税人识别号&quot;]&#x27; ); if (a !== null) &#123; console.log(&quot;进入表单页面&quot;); createButton(); clearInterval(formAuto); &#125; //写你的代码; &#125;, 1000); var codeAuto = setInterval(() =&gt; &#123; let codeSent = document.querySelector(&quot;.codeDivCls&quot;); let codeInput = document.querySelector(&#x27;[placeholder=&quot;请输入短信验证码&quot;]&#x27;); console.log(&quot;codeSent&quot;, codeSent); if (codeSent !== null) &#123; console.log(&quot;进入验证码页面&quot;); codeSent.click(); codeInput.focus(); clearInterval(codeAuto); &#125; //写你的代码; &#125;, 1000); function createButton() &#123; let form = document.querySelector(&quot;.formContentE&quot;); let lcBtn = document.createElement(&quot;button&quot;); lcBtn.innerHTML = liancheng.name; //innerText也可以,区别是innerText不会解析html lcBtn.onclick = lcInput; lcBtn.className = &quot;el-button loginCls el-button--primary&quot;; let lrBtn = document.createElement(&quot;button&quot;); lrBtn.innerHTML = lingrui.name; //innerText也可以,区别是innerText不会解析html lrBtn.onclick = lrInput; lrBtn.className = &quot;el-button loginCls el-button--primary&quot;; form.append(lcBtn); form.append(lrBtn); &#125; function lcInput() &#123; let account = document.querySelector( &#x27;[placeholder=&quot;统一社会信用代码/纳税人识别号&quot;]&#x27; ); let phone = document.querySelector( &#x27;[placeholder=&quot;居民身份证号码/手机号码/用户名&quot;]&#x27; ); let pass = document.querySelector( &#x27;[placeholder=&quot;个人用户密码(初始密码为证件号码后六位)&quot;]&#x27; ); let ev = new Event(&quot;input&quot;); let ev2 = new Event(&quot;input&quot;); let ev3 = new Event(&quot;input&quot;); setTimeout(() =&gt; &#123; account &amp;&amp; (account.value = liancheng.code) &amp;&amp; account.dispatchEvent(ev); setTimeout(() =&gt; &#123; phone &amp;&amp; (phone.value = liancheng.phone) &amp;&amp; phone.dispatchEvent(ev2); setTimeout(() =&gt; &#123; pass &amp;&amp; (pass.value = liancheng.password) &amp;&amp; pass.dispatchEvent(ev3); setTimeout(() =&gt; &#123; signIn(); &#125;, 100); &#125;, 100); &#125;, 100); &#125;, 100); slide(); &#125; function lrInput() &#123; let account = document.querySelector( &#x27;[placeholder=&quot;统一社会信用代码/纳税人识别号&quot;]&#x27; ); let phone = document.querySelector( &#x27;[placeholder=&quot;居民身份证号码/手机号码/用户名&quot;]&#x27; ); let pass = document.querySelector( &#x27;[placeholder=&quot;个人用户密码(初始密码为证件号码后六位)&quot;]&#x27; ); let ev = new Event(&quot;input&quot;); let ev2 = new Event(&quot;input&quot;); let ev3 = new Event(&quot;input&quot;); setTimeout(() =&gt; &#123; account &amp;&amp; (account.value = lingrui.code) &amp;&amp; account.dispatchEvent(ev); setTimeout(() =&gt; &#123; phone &amp;&amp; (phone.value = lingrui.phone) &amp;&amp; phone.dispatchEvent(ev2); setTimeout(() =&gt; &#123; pass &amp;&amp; (pass.value = lingrui.password) &amp;&amp; pass.dispatchEvent(ev3); setTimeout(() =&gt; &#123; signIn(); &#125;, 100); &#125;, 100); &#125;, 100); &#125;, 100); slide(); &#125; function signIn() &#123; let faterDom = document.querySelector(&quot;.el-form &quot;); let signbtn = faterDom[3]; console.log(&quot;signbtn&quot;, signbtn); //登录首页 if (signbtn) &#123; signbtn.click(); &#125; &#125; //滑块验证 function slide() &#123; var slider = document.querySelector(&quot;.handler&quot;), container = slider.parentNode; var rect = slider.getBoundingClientRect(), x0 = rect.x || rect.left, y0 = rect.y || rect.top, w = container.getBoundingClientRect().width, x1 = x0 + w, y1 = y0; var mousedown = document.createEvent(&quot;MouseEvents&quot;); mousedown.initMouseEvent( &quot;mousedown&quot;, true, true, window, 0, x0, y0, x0, y0, false, false, false, false, 0, null ); slider.dispatchEvent(mousedown); var mousemove = document.createEvent(&quot;MouseEvents&quot;); mousemove.initMouseEvent( &quot;mousemove&quot;, true, true, window, 0, x1, y1, x1, y1, false, false, false, false, 0, null ); slider.dispatchEvent(mousemove); &#125; 保存刷新后即可生效，点击插入的按钮即可完成相应的账号登录，大大节约了时间。","tags":["js","油猴脚本"],"categories":["应用笔记"]},{"title":"高德地图 搜索/定位/地图控件","path":"/2023/06/09/高德地图/","content":"简介高德地图是一款基于互联网的地图服务，提供了地图浏览、路径规划、地理编码等功能。在前端开发中，我们可以使用高德地图 JavaScript API 来实现地图相关的功能。 使用高德地图 JavaScript API，我们可以在网页中嵌入地图，并在地图上添加标记点、路径等元素，实现地图的交互功能。同时，高德地图 JavaScript API 还提供了地理编码、路径规划等功能，可以满足不同场景下的需求。 在使用高德地图 JavaScript API 进行开发时，我们需要注册高德开放平台账号，并获取 API Key。然后，在 HTML 页面中引入高德地图 JavaScript API 的 SDK，并在 JavaScript 中编写相关代码，就可以实现地图的显示和交互功能了。 演示环境 电脑 - Windows 10 Node - v16.15.0 Npm - 9.4.0 Vue 3.3.4 axios 1.4.0 基础用法原生 JS 用法，适用的平台广。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;script setup lang=&quot;ts&quot;&gt;import AMapLoader from &#x27;@amap/amap-jsapi-loader&#x27;import &#123; onMounted, shallowRef &#125; from &#x27;vue&#x27;// 在2021年12月02日以后申请的 key 需要配合您的安全密钥一起使用。window._AMapSecurityConfig = &#123; securityJsCode: &#x27;415e917da833efcf2d5b69f4d821784b&#x27;,&#125;const map = shallowRef&lt;AMap.Map&gt;()const initMap = () =&gt; &#123; AMapLoader.load(&#123; key: &#x27;4eed3d61125c8b9c168fc22414aaef7e&#x27;, // 申请好的Web端开发者Key，首次调用 load 时必填 version: &#x27;2.0&#x27;, // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15 plugins: [&#x27;&#x27;], // 需要使用的的插件列表，如比例尺&#x27;AMap.Scale&#x27;等 &#125;) .then(() =&gt; &#123; map.value = new AMap.Map(&#x27;container&#x27;, &#123; //设置地图容器id viewMode: &#x27;3D&#x27;, //是否为3D地图模式 zoom: 12, //初始化地图级别 center: [113.280637, 23.125178], //初始化地图中心点位置 &#125;) &#125;) .catch((e) =&gt; &#123; console.log(e) &#125;)&#125;onMounted(() =&gt; &#123; initMap()&#125;)&lt;/script&gt;&lt;template&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;#container &#123; padding: 0px; margin: 0px; width: 100%; height: 800px;&#125;&lt;/style&gt; Vue 组件使用起来较为方便，支持 Vue2 和 Vue3 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;const mapRef = ref()const markers = ref([ &#123; id: 1, position: [113.280637, 23.125178] &#125;, &#123; id: 2, position: [113.281657, 23.122178] &#125;,])const center = ref([113.280637, 23.125178])const zoom = ref(13)const getMap = () =&gt; &#123; // bmap vue component console.log(&#x27;setup $refs: &#x27;, mapRef.value.$$getInstance())&#125;let map: any = nullconst init = (e: any) =&gt; &#123; // 获取地图实例 console.log(&#x27;setup center: &#x27;, map === mapRef.value.$$getInstance()) console.log(&#x27;setup init $refs: &#x27;, mapRef.value.$$getInstance()) map = e&#125;// 添加坐标点1const add = () =&gt; &#123; markers.value.push(&#123; id: 3, position: [113.255657, 23.135178] &#125;)&#125;// 添加坐标点2const add2 = () =&gt; &#123; // 传统写法 const marker = new AMap.Marker(&#123; position: [113.253657, 23.133178], &#125;) map.add(marker)&#125;// 搜索，当鼠标点击或者回车选中某个POI信息时触发此事件const onSearchSelect = (e: any) =&gt; &#123; // console.log(&#x27;onSearchSelect&#x27;, e) // 设置地图中心点 center.value = e.poi.location&#125;// 定位结束后触发的事件const onGetLocationComplete = (e: any) =&gt; &#123; // 设置地图中心点 center.value = e.position&#125;&lt;/script&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;el-amap :center=&quot;center&quot; :zoom=&quot;zoom&quot; ref=&quot;mapRef&quot; @init=&quot;init&quot;&gt; &lt;!-- 标记点 --&gt; &lt;el-amap-marker v-for=&quot;marker in markers&quot; :key=&quot;marker.id&quot; :position=&quot;marker.position&quot; /&gt; &lt;!-- 地图控件 --&gt; &lt;el-amap-control-scale /&gt; &lt;el-amap-control-tool-bar :visible=&quot;false&quot; /&gt; &lt;el-amap-control-control-bar :visible=&quot;false&quot; /&gt; &lt;el-amap-control-map-type /&gt; &lt;el-amap-control-hawk-eye :visible=&quot;false&quot; /&gt; &lt;!-- 搜索 --&gt; &lt;el-amap-search-box @select=&quot;onSearchSelect&quot; /&gt; &lt;!-- 定位 --&gt; &lt;el-amap-control-geolocation @complete=&quot;onGetLocationComplete&quot; /&gt; &lt;/el-amap&gt; &lt;button @click=&quot;getMap()&quot;&gt;获取地图实例&lt;/button&gt; &lt;button @click=&quot;add()&quot;&gt;添加坐标点&lt;/button&gt; &lt;button @click=&quot;add2()&quot;&gt;添加坐标点2&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;#app &#123; height: 500px; width: 500px; background-color: pink; border: 1px solid #000;&#125;&lt;/style&gt;","tags":["高德地图","地图控件"],"categories":["应用笔记"]},{"title":"office 系列文件预览","path":"/2023/06/09/office 系列文件预览/","content":"简介如果遇到文档管理类的业务功能，会出现需要在线预览的业务需求，合同文件、发票文件等业务同样需要文件的在线预览。 本文围绕以下解决方案展开： 微软 Office Web Viewer pdfjs docx-preview xlsx 第三方封装组件 私有 Office 平台介绍 (需后端部署) 演示环境 电脑 - Windows 10 Node - v16.15.0 Npm - 9.4.0 Express - 4.18.2 微软 Office Web ViewerOffice Web Viewer 是由微软提供的一项免费服务，用户不需要安装 Office 软件，直接通过浏览器在线预览 docx、xlsx、pptx 文件。 Office Web Viewer 的服务链接为： 1https://view.officeapps.live.com/op/view.aspx?src=[文件链接] 1 其中 [文件链接] 是需要预览文件的在线地址，按需替换成自己的文件链接即可。 注意 文件会传输到微软的服务器上，因此可能会涉及到文件隐私。 不支持 pdf 预览。 适用场景 用于公网展示的文件预览，如某公告文件在线预览，能快速实现需求。 支持 docx、xlsx、pptx 文件，用于无需下载文件直接在线预览，适用于分享查看。 前端实现 出于通用性考虑，通过 encodeURIComponent 对特殊字符进行编码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;// 预览地址const officeUrl = ref(&#x27;&#x27;)// 资源地址const docx = &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.docx&#x27;const xlsx = &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.xlsx&#x27;const pptx = &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.pptx&#x27;const pdf = &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.pdf&#x27;// 使用微软 Office Web Viewer 服务预览 office 文件const previewOffice = (url: string) =&gt; &#123; // 考虑到特殊字符，通过 encodeURIComponent 处理一下 url officeUrl.value = `https://view.officeapps.live.com/op/view.aspx?src=$&#123;encodeURIComponent(url)&#125;`&#125;// 复制分享地址const copyToClipboard = async (text: string) =&gt; &#123; await navigator.clipboard.writeText(text) alert(&#x27;复制成功&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;btns&quot;&gt; &lt;!-- 微软 Office Web Viewer 服务 --&gt; &lt;button @click=&quot;previewOffice(docx)&quot;&gt;预览docx&lt;/button&gt; &lt;button @click=&quot;previewOffice(xlsx)&quot;&gt;预览xlsx&lt;/button&gt; &lt;button @click=&quot;previewOffice(pptx)&quot;&gt;预览pptx&lt;/button&gt; &lt;!-- pdf 直接预览 --&gt; &lt;button @click=&quot;officeUrl = pdf&quot;&gt;预览pdf&lt;/button&gt; &lt;!-- 复制分享地址 --&gt; &lt;button class=&quot;copy-btn&quot; v-if=&quot;officeUrl&quot; @click=&quot;copyToClipboard(officeUrl)&quot;&gt; 复制分享地址 &lt;/button&gt; &lt;/div&gt; &lt;!-- 通过 iframe 嵌入 --&gt; &lt;iframe class=&quot;previewOffice&quot; :src=&quot;officeUrl&quot;&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;body &#123; margin: 0;&#125;.container &#123; width: 100vw; height: 100vh; display: flex; flex-direction: column; .previewOffice &#123; flex: 1; &#125; .copy-btn &#123; background-color: #070; color: #fff; &#125;&#125;&lt;/style&gt; pdf 预览通过 PDF.js 加载 PDF 文件，渲染到 Canvas 上。 安装依赖 npm i pdfjs-dist 设置 workerSrc 的值 官方教程 业务场景 渲染 pdf 的需求较为常见，如预览电子发票，合同，学术论文等。 本地选择1234567891011121314151617181920212223242526272829303132333435&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import * as pdfjsLib from &#x27;pdfjs-dist&#x27;// 设置 workerSrc 的值，cdn 远程加载pdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/$&#123;pdfjsLib.version&#125;/pdf.worker.js`const canvasRef = ref&lt;HTMLCanvasElement&gt;()const previewPdf = async (event: Event) =&gt; &#123; // 获取文件 const file = (event.target as HTMLInputElement).files?.[0] // 获取 canvas const canvas = canvasRef.value if (file &amp;&amp; canvas) &#123; const ctx = canvas.getContext(&#x27;2d&#x27;) if (!ctx) return const data = await file.arrayBuffer() pdfjsLib.getDocument(&#123; data &#125;).promise.then((pdf) =&gt; &#123; pdf.getPage(1).then((page) =&gt; &#123; const viewport = page.getViewport(&#123; scale: 1.5 &#125;) canvas.width = viewport.width canvas.height = viewport.height page.render(&#123; canvasContext: ctx, viewport &#125;) &#125;) &#125;) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;!-- pdf 预览 --&gt; &lt;input type=&quot;file&quot; accept=&quot;.pdf&quot; @change=&quot;previewPdf&quot; /&gt; &lt;br /&gt; &lt;canvas ref=&quot;canvasRef&quot;&gt;&lt;/canvas&gt;&lt;/template&gt; 远程请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;script setup lang=&quot;ts&quot;&gt;import * as pdfjsLib from &#x27;pdfjs-dist&#x27;import &#123; ref &#125; from &#x27;vue&#x27;import axios from &#x27;axios&#x27;// 设置 workerSrc 的值，cdn 远程加载pdfjsLib.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/$&#123;pdfjsLib.version&#125;/pdf.worker.js`const canvasRef = ref&lt;HTMLCanvasElement&gt;()const file = ref()const getFile = async () =&gt; &#123; const res = await axios(&#123; method: &#x27;get&#x27;, url: &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.pdf&#x27;, responseType: &#x27;arraybuffer&#x27;, &#125;) file.value = res.data&#125;const previewFile = async () =&gt; &#123; await getFile() const canvas = canvasRef.value if (file.value &amp;&amp; canvas) &#123; const ctx = canvas.getContext(&#x27;2d&#x27;) if (!ctx) return const data = new Uint8Array(file.value) pdfjsLib.getDocument(&#123; data &#125;).promise.then((pdf) =&gt; &#123; pdf.getPage(1).then((page) =&gt; &#123; const viewport = page.getViewport(&#123; scale: 1.5 &#125;) canvas.width = viewport.width canvas.height = viewport.height page.render(&#123; canvasContext: ctx, viewport &#125;) &#125;) &#125;) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;previewFile&quot;&gt;获取文档&lt;/button&gt; &lt;br /&gt; &lt;!-- pdf 预览容器 --&gt; &lt;canvas ref=&quot;canvasRef&quot;&gt;&lt;/canvas&gt;&lt;/template&gt; docx 预览通过 docx-preview 加载 docx 文件。 安装依赖 npm i docx-preview 调用 renderAsync 方法来渲染文档 官方文档 本地选择1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; defaultOptions, renderAsync &#125; from &#x27;docx-preview&#x27;// 定义一个 ref 来存储容器元素const container = ref&lt;HTMLElement&gt;()// 定义一个异步函数 previewFile 来预览文档const previewFile = async (event: Event) =&gt; &#123; // 获取上传的文件 const file = (event.target as HTMLInputElement).files?.[0] if (file &amp;&amp; container.value) &#123; // 将文件转换为 ArrayBuffer const arrayBuffer = await file.arrayBuffer() // 调用 renderAsync 方法来渲染文档 await renderAsync(arrayBuffer, container.value, undefined, &#123; ...defaultOptions, className: &#x27;docx&#x27;, inWrapper: true, ignoreWidth: false, ignoreHeight: false, ignoreFonts: false, breakPages: true, ignoreLastRenderedPageBreak: true, experimental: false, trimXmlDeclaration: true, debug: false, &#125;) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;!-- 添加一个文件上传的 input 元素，绑定 change 事件到 previewFile 函数 --&gt; &lt;input type=&quot;file&quot; accept=&quot;.docx&quot; @change=&quot;previewFile&quot; /&gt; &lt;!-- 添加一个 div 元素，通过 ref 绑定到 container 变量 --&gt; &lt;div ref=&quot;container&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 远程请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; defaultOptions, renderAsync &#125; from &#x27;docx-preview&#x27;import axios from &#x27;axios&#x27;// 定义一个 ref 来存储容器元素const container = ref&lt;HTMLElement&gt;()const fileRef = ref()const getFile = async () =&gt; &#123; const res = await axios(&#123; method: &#x27;get&#x27;, url: &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.docx&#x27;, // 返回类型为 arraybuffer responseType: &#x27;arraybuffer&#x27;, &#125;) fileRef.value = res.data&#125;// 定义一个异步函数 previewFile 来预览文档const previewFile = async () =&gt; &#123; // 获取文档 await getFile() // 获取 arraybuffer const file = fileRef.value if (file &amp;&amp; container.value) &#123; // 调用 renderAsync 方法来渲染文档 await renderAsync(file, container.value, undefined, &#123; ...defaultOptions, className: &#x27;docx&#x27;, inWrapper: true, ignoreWidth: false, ignoreHeight: false, ignoreFonts: false, breakPages: true, ignoreLastRenderedPageBreak: true, experimental: false, trimXmlDeclaration: true, debug: false, &#125;) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;previewFile&quot;&gt;获取文档&lt;/button&gt; &lt;br /&gt; &lt;!-- 添加一个 div 元素，通过 ref 绑定到 container 变量 --&gt; &lt;div ref=&quot;container&quot;&gt;&lt;/div&gt;&lt;/template&gt; xlsx 预览通过 xlsx 加载 xlsx 文件。 安装依赖 npm i xlsx 调用相关方法获取 excel 文件数据 官方教程 本地选择1234567891011121314151617181920212223242526272829303132333435363738&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; read, utils &#125; from &#x27;xlsx&#x27;// 本地选择文件const rows = ref&lt;any&gt;([])const previewFile = async (event: Event) =&gt; &#123; // 获取上传的文件 const file = (event.target as HTMLInputElement).files?.[0] if (file) &#123; // 将文件转换为 ArrayBuffer const arrayBuffer = await file.arrayBuffer() // 读取 Sheets const sheet = read(arrayBuffer).Sheets /* 渲染数据 */ rows.value = utils.sheet_to_json(sheet[&#x27;Data&#x27;]) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;input type=&quot;file&quot; accept=&quot;.xlsx&quot; ref=&quot;fileInput&quot; @change=&quot;previewFile&quot; /&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Index&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(item, index) in rows&quot; :key=&quot;index&quot;&gt; &lt;td&gt;&#123;&#123; item.Name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.Index &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/template&gt; 远程请求123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script setup lang=&quot;ts&quot;&gt;import axios from &#x27;axios&#x27;import &#123; ref &#125; from &#x27;vue&#x27;import &#123; read, utils &#125; from &#x27;xlsx&#x27;const getFile = async () =&gt; &#123; const res = await axios(&#123; method: &#x27;get&#x27;, url: &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.xlsx&#x27;, // 返回类型为 arraybuffer responseType: &#x27;arraybuffer&#x27;, &#125;) return res.data&#125;const rows = ref&lt;any&gt;([])const previewFile = async () =&gt; &#123; const arrayBuffer = await getFile() if (arrayBuffer) &#123; // 读取 Sheets const sheet = read(arrayBuffer).Sheets /* 渲染数据 */ rows.value = utils.sheet_to_json(sheet[&#x27;Data&#x27;]) &#125;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;previewFile&quot;&gt;获取文档&lt;/button&gt; &lt;br /&gt; &lt;table&gt; &lt;thead&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Index&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr v-for=&quot;(item, index) in rows&quot; :key=&quot;index&quot;&gt; &lt;td&gt;&#123;&#123; item.Name &#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.Index &#125;&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/template&gt; vue-office 组件 - 推荐支持多种文件(docx、excel、pdf)预览的 vue 组件库。 同时支持 vue2&#x2F;3 使用简单 支持本地文件 支持远程地址 官方文档 pdf 预览 安装依赖 npm i @vue-office/pdf 12345678910111213141516171819202122232425&lt;script setup lang=&quot;ts&quot;&gt;// 引入 VueOffice 组件import VueOfficePdf from &#x27;@vue-office/pdf&#x27;import &#123; ref &#125; from &#x27;vue&#x27;// 设置文档网络地址，可以是本地文件const src = ref()// 本地预览const previewFile = async (event: Event) =&gt; &#123; const file = (event.target as HTMLInputElement).files?.[0] src.value = file&#125;// 请求预览const getFile = () =&gt; &#123; src.value = &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.pdf&#x27;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;getFile&quot;&gt;获取远程&lt;/button&gt; &lt;input type=&quot;file&quot; accept=&quot;.pdf&quot; @change=&quot;previewFile&quot; /&gt; &lt;vue-office-pdf :src=&quot;src&quot; style=&quot;height: 100vh&quot; /&gt;&lt;/template&gt; docx 预览 安装依赖 npm i @vue-office/docx 123456789101112131415161718192021222324252627&lt;script setup lang=&quot;ts&quot;&gt;// 引入 VueOffice 组件import VueOfficeDocx from &#x27;@vue-office/docx&#x27;// 引入相关样式import &#x27;@vue-office/docx/lib/index.css&#x27;import &#123; ref &#125; from &#x27;vue&#x27;// 设置文档网络地址，可以是本地文件const src = ref()// 本地预览const previewFile = async (event: Event) =&gt; &#123; const file = (event.target as HTMLInputElement).files?.[0] src.value = file&#125;// 请求预览const getFile = () =&gt; &#123; src.value = &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.docx&#x27;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;getFile&quot;&gt;获取远程&lt;/button&gt; &lt;input type=&quot;file&quot; accept=&quot;.docx&quot; @change=&quot;previewFile&quot; /&gt; &lt;vue-office-docx :src=&quot;src&quot; style=&quot;height: 100vh&quot; /&gt;&lt;/template&gt; xlsx 预览 安装依赖 npm i @vue-office/excel 123456789101112131415161718192021222324252627&lt;script setup lang=&quot;ts&quot;&gt;// 引入 VueOffice 组件import VueOfficeExcel from &#x27;@vue-office/excel&#x27;// 引入相关样式import &#x27;@vue-office/excel/lib/index.css&#x27;import &#123; ref &#125; from &#x27;vue&#x27;// 设置文档网络地址，可以是本地文件const src = ref()// 本地预览const previewFile = async (event: Event) =&gt; &#123; const file = (event.target as HTMLInputElement).files?.[0] src.value = file&#125;// 请求预览const getFile = () =&gt; &#123; src.value = &#x27;https://yjy-teach-oss.oss-cn-beijing.aliyuncs.com/solution/demo.xlsx&#x27;&#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;getFile&quot;&gt;获取远程&lt;/button&gt; &lt;input type=&quot;file&quot; accept=&quot;.xlsx&quot; @change=&quot;previewFile&quot; /&gt; &lt;vue-office-excel :src=&quot;src&quot; style=&quot;height: 100vh&quot; /&gt;&lt;/template&gt; 私有化 office 部署(运维部署)ONLYOFFICE Docs是一个免费的协作在线办公套件，包括文本、电子表格和演示文稿的查看器和编辑器，还有表单和PDF，完全兼容Office Open XML格式：.docx、.xlsx、.pptx，并支持实时协作编辑。 类似国内的腾讯文档，金山文档，在线 WPS 文档，而 ONLYOFFICE 可私有化部署到公司服务器，文件隐私相对更高，部署工作由公司运维负责。 ONLY OFFICE 开源仓库 - star 3.4k ONLY OFFICE docker 部署教程 ONLY OFFICE 社区版部署教程 扩展阅读 微软官方 office 在线预览 前端实现文件的预览 pdf.js - star 43k pdfjs examples - Mozilla vue-office 组件 - star 824 file-view 组件 - star 242 OFFICE TO HTML - star 158 onlyoffice 社区版部署教程","tags":["pdf.js","office","express"],"categories":["应用笔记"]},{"title":"大文件上传 分片 续传 秒传","path":"/2023/06/08/大文件上传 分片 续传 秒传/","content":"前言在日常开发中，文件上传是常见的操作之一。文件上传技术使得用户可以方便地将本地文件上传到 Web 服务器上，这在许多场景下都是必需的，比如网盘上传、头像上传等。 但是当我们需要上传比较大的文件的时候，容易碰到以下问题： 上传时间比较久 中间一旦出错就需要重新上传 一般服务端会对文件的大小进行限制 这两个问题会导致上传时候的用户体验是很不好的，针对存在的这些问题，我们可以通过分片上传来解决，这节课我们就在学习下什么是切片上传，以及怎么实现切片上传。 演示环境 电脑 - Windows 10 Node - v16.15.0 Npm - 9.4.0 Express - 4.18.2 原理介绍分片上传的原理就像是把一个大蛋糕切成小块一样。 首先，我们将要上传的大文件分成许多小块，每个小块大小相同，比如每块大小为 2MB。然后，我们逐个上传这些小块到服务器。上传的时候，可以同时上传多个小块，也可以一个一个地上传。上传每个小块后，服务器会保存这些小块，并记录它们的顺序和位置信息。 所有小块上传完成后，服务器会把这些小块按照正确的顺序拼接起来，还原成完整的大文件。最后，我们就成功地上传了整个大文件。 分片上传的好处在于它可以减少上传失败的风险。如果在上传过程中出现了问题，只需要重新上传出错的那个小块，而不需要重新上传整个大文件。 此外，分片上传还可以加快上传速度。因为我们可以同时上传多个小块，充分利用网络的带宽。这样就能够更快地完成文件的上传过程。 项目搭建要实现大文件上传，还需要后端的支持，所以我们就用 nodejs 来写后端代码。 前端：vue3 + vite 后端：express 框架，用到的工具包：multiparty、fs-extra、cors、body-parser、nodemon 读取文件通过监听 input 的 change 事件，当选取了本地文件后，可以在回调函数中拿到对应的文件： 12345678const handleUpload = (e: Event) =&gt; &#123; const files = (e.target as HTMLInputElement).files if (!files) &#123; return &#125; // 读取选择的文件 console.log(files[0]);&#125; 文件分片文件分片的核心是用Blob 对象的 slice 方法，我们在上一步获取到选择的文件是一个File对象，它是继承于Blob，所以我们就可以用slice方法对文件进行分片，用法如下： 1let blob = instanceOfBlob.slice([start [, end [, contentType]]]&#125;; start 和 end 代表 Blob 里的下标，表示被拷贝进新的 Blob 的字节的起始位置和结束位置。contentType 会给新的 Blob 赋予一个新的文档类型，在这里我们用不到。接下来就来使用slice方法来实现下对文件的分片。 1234567891011const createFileChunks = (file: File) =&gt; &#123; const fileChunkList = [] let cur = 0 while (cur &lt; file.size) &#123; fileChunkList.push(&#123; file: file.slice(cur, cur + CHUNK_SIZE), &#125;) cur += CHUNK_SIZE // CHUNK_SIZE为分片的大小 &#125; return fileChunkList&#125; hash 计算先来思考一个问题，在向服务器上传文件时，怎么去区分不同的文件呢？如果根据文件名去区分的话可以吗？ 答案是不可以，因为文件名我们可以是随便修改的，所以不能根据文件名去区分。但是每一份文件的文件内容都不一样，我们可以根据文件的内容去区分，具体怎么做呢？ 可以根据文件内容生产一个唯一的 hash 值，大家应该都见过用 webpack 打包出来的文件的文件名都有一串不一样的字符串，这个字符串就是根据文件的内容生成的 hash 值，文件内容变化，hash 值就会跟着发生变化。我们在这里，也可以用这个办法来区分不同的文件。而且通过这个办法，我们还可以实现秒传的功能，怎么做呢？ 就是服务器在处理上传文件的请求的时候，要先判断下对应文件的 hash 值有没有记录，如果 A 和 B 先后上传一份内容相同的文件，所以这两份文件的 hash 值是一样的。当 A 上传的时候会根据文件内容生成一个对应的 hash 值，然后在服务器上就会有一个对应的文件，B 再上传的时候，服务器就会发现这个文件的 hash 值之前已经有记录了，说明之前已经上传过相同内容的文件了，所以就不用处理 B 的这个上传请求了，给用户的感觉就像是实现了秒传。 那么怎么计算文件的 hash 值呢？可以通过一个工具：spark-md5，所以我们得先安装它。 在上一步获取到了文件的所有切片，我们就可以用这些切片来算该文件的 hash 值，但是如果一个文件特别大，每个切片的所有内容都参与计算的话会很耗时间，所有我们可以采取以下策略： 第一个和最后一个切片的内容全部参与计算 中间剩余的切片我们分别在前面、后面和中间取 2 个字节参与计算 这样就既能保证所有的切片参与了计算，也能保证不耗费很长的时间 12345678910111213141516171819202122232425262728293031323334/** * 计算文件的hash值，计算的时候并不是根据所用的切片的内容去计算的，那样会很耗时间，我们采取下面的策略去计算： * 1. 第一个和最后一个切片的内容全部参与计算 * 2. 中间剩余的切片我们分别在前面、后面和中间取2个字节参与计算 * 这样做会节省计算hash的时间 */const calculateHash = async (fileChunks: Array&lt;&#123;file: Blob&#125;&gt;) =&gt; &#123; return new Promise(resolve =&gt; &#123; const spark = new sparkMD5.ArrayBuffer() const chunks: Blob[] = [] fileChunks.forEach((chunk, index) =&gt; &#123; if (index === 0 || index === fileChunks.length - 1) &#123; // 1. 第一个和最后一个切片的内容全部参与计算 chunks.push(chunk.file) &#125; else &#123; // 2. 中间剩余的切片我们分别在前面、后面和中间取2个字节参与计算 // 前面的2字节 chunks.push(chunk.file.slice(0, 2)) // 中间的2字节 chunks.push(chunk.file.slice(CHUNK_SIZE / 2, CHUNK_SIZE / 2 + 2)) // 后面的2字节 chunks.push(chunk.file.slice(CHUNK_SIZE - 2, CHUNK_SIZE)) &#125; &#125;) const reader = new FileReader() reader.readAsArrayBuffer(new Blob(chunks)) reader.onload = (e: Event) =&gt; &#123; spark.append(e?.target?.result as ArrayBuffer) resolve(spark.end()) &#125; &#125;)&#125; 文件上传前端实现前面已经完成了上传的前置操作，接下来就来看下如何去上传这些切片。 我们以 1G 的文件来分析，假如每个分片的大小为 1M，那么总的分片数将会是 1024 个，如果我们同时发送这 1024 个分片，浏览器肯定处理不了，原因是切片文件过多，浏览器一次性创建了太多的请求。这是没有必要的，拿 chrome 浏览器来说，默认的并发数量只有 6，过多的请求并不会提升上传速度，反而是给浏览器带来了巨大的负担。因此，我们有必要限制前端请求个数。 怎么做呢，我们要创建最大并发数的请求，比如 6 个，那么同一时刻我们就允许浏览器只发送 6 个请求，其中一个请求有了返回的结果后我们再发起一个新的请求，依此类推，直至所有的请求发送完毕。 上传文件时一般还要用到 FormData 对象，需要将我们要传递的文件还有额外信息放到这个 FormData 对象里面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const uploadChunks = async (fileChunks: Array&lt;&#123; file: Blob &#125;&gt;) =&gt; &#123; const data = fileChunks.map((&#123; file &#125;, index) =&gt; (&#123; fileHash: fileHash.value, index, chunkHash: `$&#123;fileHash.value&#125;-$&#123;index&#125;`, chunk: file, size: file.size, &#125;)) const formDatas = data.map((&#123; chunk, chunkHash &#125;) =&gt; &#123; const formData = new FormData() // 切片文件 formData.append(&#x27;chunk&#x27;, chunk) // 切片文件hash formData.append(&#x27;chunkHash&#x27;, chunkHash) // 大文件的文件名 formData.append(&#x27;fileName&#x27;, fileName.value) // 大文件hash formData.append(&#x27;fileHash&#x27;, fileHash.value) return formData &#125;) let index = 0 const max = 6 // 并发请求数量 const taskPool: any = [] // 请求队列 while (index &lt; formDatas.length) &#123; const task = fetch(&#x27;http://127.0.0.1:3000/upload&#x27;, &#123; method: &#x27;POST&#x27;, body: formDatas[index], &#125;) task.then(() =&gt; &#123; taskPool.splice(taskPool.findIndex((item: any) =&gt; item === task)) &#125;) taskPool.push(task) if (taskPool.length === max) &#123; // 当请求队列中的请求数达到最大并行请求数的时候，得等之前的请求完成再循环下一个 await Promise.race(taskPool) &#125; index++ percentage.value = ((index / formDatas.length) * 100).toFixed(0) &#125; await Promise.all(taskPool)&#125; 写完前后端代码后就可以来试下看看文件能不能实现切片的上传，如果没有错误的话，我们的 uploads 文件夹下应该就会多一个文件夹，这个文件夹里面就是存储的所有文件的分片了。 文件合并上一步我们已经实现了将所有切片上传到服务器了，上传完成之后，我们就可以将所有的切片合并成一个完整的文件了，下面就一块来实现下。 前端实现前端只需要向服务器发送一个合并的请求，并且为了区分要合并的文件，需要将文件的 hash 值给传过去 123456789101112131415161718192021/** * 发请求通知服务器，合并切片 */const mergeRequest = () =&gt; &#123; // 发送合并请求 fetch(&#x27;http://127.0.0.1:3000/merge&#x27;, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#125;, body: JSON.stringify(&#123; size: CHUNK_SIZE, fileHash: fileHash.value, fileName: fileName.value, &#125;), &#125;) .then((response) =&gt; response.json()) .then(() =&gt; &#123; alert(&#x27;上传成功&#x27;) &#125;)&#125; 后端实现在之前已经可以将所有的切片上传到服务器并存储到对应的目录里面去了，合并的时候需要从对应的文件夹中获取所有的切片，然后利用文件的读写操作，就可以实现文件的合并了。合并完成之后，我们将生成的文件以 hash 值命名存放到对应的位置就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// 提取文件后缀名const extractExt = (filename) =&gt; &#123; return filename.slice(filename.lastIndexOf(&#x27;.&#x27;), filename.length)&#125;/** * 读的内容写到writeStream中 */const pipeStream = (path, writeStream) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; // 创建可读流 const readStream = fse.createReadStream(path) readStream.on(&#x27;end&#x27;, async () =&gt; &#123; fse.unlinkSync(path) resolve() &#125;) readStream.pipe(writeStream) &#125;)&#125;/** * 合并文件夹中的切片，生成一个完整的文件 */async function mergeFileChunk(filePath, fileHash, size) &#123; const chunkDir = path.resolve(UPLOAD_DIR, fileHash) const chunkPaths = await fse.readdir(chunkDir) // 根据切片下标进行排序 // 否则直接读取目录的获得的顺序可能会错乱 chunkPaths.sort((a, b) =&gt; &#123; return a.split(&#x27;-&#x27;)[1] - b.split(&#x27;-&#x27;)[1] &#125;) const list = chunkPaths.map((chunkPath, index) =&gt; &#123; return pipeStream( path.resolve(chunkDir, chunkPath), fse.createWriteStream(filePath, &#123; start: index * size, end: (index + 1) * size, &#125;), ) &#125;) await Promise.all(list) // 文件合并后删除保存切片的目录 fse.rmdirSync(chunkDir)&#125;// 合并文件app.post(&#x27;/merge&#x27;, async (req, res) =&gt; &#123; const &#123; fileHash, fileName, size &#125; = req.body const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;extractExt(fileName)&#125;`) // 如果大文件已经存在，则直接返回 if (fse.existsSync(filePath)) &#123; res.status(200).json(&#123; ok: true, msg: &#x27;合并成功&#x27;, &#125;) return &#125; const chunkDir = path.resolve(UPLOAD_DIR, fileHash) // 切片目录不存在，则无法合并切片，报异常 if (!fse.existsSync(chunkDir)) &#123; res.status(200).json(&#123; ok: false, msg: &#x27;合并失败，请重新上传&#x27;, &#125;) return &#125; await mergeFileChunk(filePath, fileHash, size) res.status(200).json(&#123; ok: true, msg: &#x27;合并成功&#x27;, &#125;)&#125;) 到这里，我们就已经实现了大文件的分片上传的基本功能了，但是我们没有考虑到如果上传相同的文件的情况，而且如果中间网络断了，我们就得重新上传所有的分片，这些情况在大文件上传中也都需要考虑到，下面，我们就来解决下这两个问题。 秒传&amp;断点续传我们在上面有提到，如果内容相同的文件进行 hash 计算时，对应的 hash 值应该是一样的，而且我们在服务器上给上传的文件命名的时候就是用对应的 hash 值命名的，所以在上传之前是不是可以加一个判断，如果有对应的这个文件，就不用再重复上传了，直接告诉用户上传成功，给用户的感觉就像是实现了秒传。接下来，就来看下如何实现的。 前端实现前端在上传之前，需要将对应文件的 hash 值告诉服务器，看看服务器上有没有对应的这个文件，如果有，就直接返回，不执行上传分片的操作了。 1234567891011121314151617181920212223242526272829303132333435363738/** * 验证该文件是否需要上传，文件通过hash生成唯一，改名后也是不需要再上传的，也就相当于秒传 */const verifyUpload = async () =&gt; &#123; return fetch(&#x27;http://127.0.0.1:3000/verify&#x27;, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#125;, body: JSON.stringify(&#123; fileName: fileName.value, fileHash: fileHash.value, &#125;), &#125;) .then((response) =&gt; response.json()) .then((data) =&gt; &#123; return data // data中包含对应的表示服务器上有没有该文件的查询结果 &#125;)&#125;// 点击上传事件const handleUpload = async (e: Event) =&gt; &#123; // ... // uploadedList已上传的切片的切片文件名称 const res = await verifyUpload() const &#123; shouldUpload &#125; = res.data if (!shouldUpload) &#123; // 服务器上已经有该文件，不需要上传 alert(&#x27;秒传：上传成功&#x27;) return &#125; // 服务器上不存在该文件，继续上传 uploadChunks(fileChunks)&#125; 后端实现因为我们在合并文件时，文件名时根据该文件的 hash 值命名的，所以只需要看看服务器上有没有对应的这个 hash 值的那个文件就可以判断了。 1234567891011121314151617181920212223// 根据文件hash验证文件有没有上传过app.post(&#x27;/verify&#x27;, async (req, res) =&gt; &#123; const &#123; fileHash, fileName &#125; = req.body const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;extractExt(fileName)&#125;`) if (fse.existsSync(filePath)) &#123; // 文件存在服务器中，不需要再上传了 res.status(200).json(&#123; ok: true, data: &#123; shouldUpload: false, &#125;, &#125;) &#125; else &#123; // 文件不在服务器中，就需要上传 res.status(200).json(&#123; ok: true, data: &#123; shouldUpload: true, &#125;, &#125;) &#125;&#125;) 完成上面的步骤后，当我们再上传相同的文件，即使改了文件名，也会提示我们秒传成功了，因为服务器上已经有对应的那个文件了。 上面我们解决了重复上传的文件，但是对于网络中断需要重新上传的问题没有解决，那该如何解决呢？ 如果我们之前已经上传了一部分分片了，我们只需要再上传之前拿到这部分分片，然后再过滤掉是不是就可以避免去重复上传这些分片了，也就是只需要上传那些上传失败的分片，所以，再上传之前还得加一个判断。 前端实现我们还是在那个 verify 的接口中去获取已经上传成功的分片，然后在上传分片前进行一个过滤 123456789101112131415161718192021const uploadChunks = async (fileChunks: Array&lt;&#123; file: Blob &#125;&gt;, uploadedList: Array&lt;string&gt;) =&gt; &#123; const formDatas = fileChunks .filter((chunk, index) =&gt; &#123; // 过滤服务器上已经有的切片 return !uploadedList.includes(`$&#123;fileHash.value&#125;-$&#123;index&#125;`) &#125;) .map((&#123; file &#125;, index) =&gt; &#123; const formData = new FormData() // 切片文件 formData.append(&#x27;file&#x27;, file) // 切片文件hash formData.append(&#x27;chunkHash&#x27;, `$&#123;fileHash.value&#125;-$&#123;index&#125;`) // 大文件的文件名 formData.append(&#x27;fileName&#x27;, fileName.value) // 大文件hash formData.append(&#x27;fileHash&#x27;, fileHash.value) return formData &#125;) // ...&#125; 后端实现只需要在 /verify 这个接口中加上已经上传成功的所有切片的名称就可以，因为所有的切片都存放在以文件的 hash 值命名的那个文件夹，所以需要读取这个文件夹中所有的切片的名称就可以。 1234567891011121314151617181920212223242526272829303132333435/** * 返回已经上传切片名 * @param &#123;*&#125; fileHash * @returns */const createUploadedList = async (fileHash) =&gt; &#123; return fse.existsSync(path.resolve(UPLOAD_DIR, fileHash)) ? await fse.readdir(path.resolve(UPLOAD_DIR, fileHash)) // 读取该文件夹下所有的文件的名称 : []&#125;// 根据文件hash验证文件有没有上传过app.post(&#x27;/verify&#x27;, async (req, res) =&gt; &#123; const &#123; fileHash, fileName &#125; = req.body const filePath = path.resolve(UPLOAD_DIR, `$&#123;fileHash&#125;$&#123;extractExt(fileName)&#125;`) if (fse.existsSync(filePath)) &#123; // 文件存在服务器中，不需要再上传了 res.status(200).json(&#123; ok: true, data: &#123; shouldUpload: false, &#125;, &#125;) &#125; else &#123; // 文件不在服务器中，就需要上传，并且返回服务器上已经存在的切片 res.status(200).json(&#123; ok: true, data: &#123; shouldUpload: true, uploadedList: await createUploadedList(fileHash), &#125;, &#125;) &#125;&#125;)","tags":["js","文件上传"],"categories":["知识技能"]},{"title":"虚拟列表-渲染 10 万条数据","path":"/2023/06/08/虚拟列表-渲染 10 万条数据/","content":"简介虚拟列表是一种优化长列表渲染的技术，它可以在保持流畅性的同时，渲染大量的数据。 在传统的列表渲染中，如果列表非常长，会导致渲染时间过长，页面卡顿，用户体验变得非常差。而虚拟列表则是只渲染可见区域内的数据，而非全部渲染，这样就可以大大提高渲染效率，保持页面流畅性。 应用场景 虚拟列表技术在大数据量列表渲染场景中应用广泛，例如电商商品列表、社交动态列表等。 我们主要围绕以下几个部分讲解： 虚拟列表实现原理 VueUse 方案 vue-virtual-scroller 方案 演示环境 电脑 - Windows 10 Node - v16.15.0 Npm - 9.4.0 Express - 4.18.2 后端服务为了便于演示，我们用 express 返回 10 万条数据。 1234567891011121314151617181920212223242526272829const express = require(&#x27;express&#x27;)const cors = require(&#x27;cors&#x27;)// 创建 express 实例const app = express()// 允许跨域app.use(cors())// 主机const host = &#x27;http://localhost&#x27;// 端口const port = 3000// 获取十万条数据app.get(&#x27;/large-data&#x27;, (req, res) =&gt; &#123; // 定义数组，用于存放十万条数据 const data = [] // 循环十万次 for (let i = 1; i &lt;= 100000; i++) &#123; // 循环添加十万条数据 data.push(&#123; id: i, name: `名字$&#123;i&#125;`, value: i &#125;) &#125; // 返回十万条数据 res.send(&#123; code: 0, msg: &#x27;成功&#x27;, data &#125;)&#125;)// 启动服务器app.listen(port, () =&gt; &#123; console.log(`$&#123;host&#125;:$&#123;port&#125;`)&#125;) 虚拟列表-实现原理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;script setup lang=&quot;ts&quot;&gt;import axios from &#x27;axios&#x27;import &#123; computed, onMounted, ref &#125; from &#x27;vue&#x27;type Item = &#123; id: number name: string&#125;// 所有的数据，比如这个数组存放了十万条数据const allListData = ref&lt;Item[]&gt;([])const itemHeight = ref(40) // 每一条（项）的高度，比如 40 像素const count = ref(10) // 一屏展示几条数据const startIndex = ref(0) // 开始位置的索引const endIndex = ref(10) // 结束位置的索引const topVal = ref(0) // 父元素滚动位置// 计算展示的列表const showListData = computed(() =&gt; allListData.value.slice(startIndex.value, endIndex.value))// 获取十万条数据const getData = async () =&gt; &#123; const res = await axios.get(&#x27;http://localhost:3000/large-data&#x27;) allListData.value = res.data.data&#125;// 初始化加载onMounted(() =&gt; &#123; getData()&#125;)// 虚拟列表视口const viewport = ref&lt;HTMLDivElement&gt;()// 滚动这里可以加上节流，减少触发频次const handleScroll = () =&gt; &#123; // 非空判断 if (!viewport.value) return // 获取滚动距离 const scrollTop = viewport.value.scrollTop // 计算起始下标和结束下标，用于 computed 计算 startIndex.value = Math.floor(scrollTop / itemHeight.value) endIndex.value = startIndex.value + count.value // 动态更改定位的 top 值，确保联动，动态展示相应内容 topVal.value = viewport.value.scrollTop&#125;&lt;/script&gt;&lt;template&gt; &lt;h2&gt;手写虚拟列表-原理&#123;&#123; topVal &#125;&#125;&lt;/h2&gt; &lt;!-- 虚拟列表容器：类似“视口”，视口的高度取决于一次展示几条数据 比如视口只能看到10条数据，一条40像素，10条400像素 故，视口的高度为400像素，注意要开定位和滚动条 --&gt; &lt;div class=&quot;viewport&quot; ref=&quot;viewport&quot; @scroll=&quot;handleScroll&quot; :style=&quot;&#123; height: itemHeight * count + &#x27;px&#x27; &#125;&quot; &gt; &lt;!-- 占位 dom 元素，其高度为所有的数据的总高度 --&gt; &lt;div class=&quot;placeholder&quot; :style=&quot;&#123; height: allListData.length * itemHeight + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;!-- 内容区，展示10条数据，注意其定位的top值是变化的 --&gt; &lt;div class=&quot;list&quot; :style=&quot;&#123; top: topVal + &#x27;px&#x27; &#125;&quot;&gt; &lt;!-- 每一条（项）数据 --&gt; &lt;div v-for=&quot;item in showListData&quot; :key=&quot;item.id&quot; class=&quot;item&quot; :style=&quot;&#123; height: itemHeight + &#x27;px&#x27; &#125;&quot; &gt; &#123;&#123; item.name &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;// 虚拟列表容器盒子.viewport &#123; box-sizing: border-box; width: 240px; border: solid 1px #000000; // 开启滚动条 overflow-y: auto; // 开启相对定位 position: relative; .list &#123; width: 100%; height: auto; // 搭配使用绝对定位 position: absolute; top: 0; left: 0; .item &#123; box-sizing: border-box; width: 100%; height: 40px; line-height: 40px; text-align: center; // 隔行变色 &amp;:nth-child(even) &#123; background: #c7edcc; &#125; &amp;:nth-child(odd) &#123; background: pink; &#125; &#125; &#125;&#125;&lt;/style&gt; VueUse 组合式函数安装依赖 1pnpm install @vueuse/core 参考链接：https://vueuse.org/core/useVirtualList/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useVirtualList &#125; from &#x27;@vueuse/core&#x27;import axios from &#x27;axios&#x27;import &#123; onMounted, ref &#125; from &#x27;vue&#x27;type Item = &#123; id: number name: string&#125;// 所有的数据，比如这个数组存放了十万条数据const allListData = ref&lt;Item[]&gt;([])// 获取十万条数据const getData = async () =&gt; &#123; const res = await axios.get(&#x27;http://localhost:3000/large-data&#x27;) allListData.value = res.data.data&#125;// 初始化加载onMounted(() =&gt; &#123; getData()&#125;)// 每一项的高度，比如 40 像素const itemHeight = ref(40)// vueuse方案：https://vueuse.org/core/useVirtualList/const &#123; list, containerProps, wrapperProps &#125; = useVirtualList(allListData, &#123; itemHeight: itemHeight.value,&#125;)&lt;/script&gt;&lt;template&gt; &lt;h2&gt;虚拟列表-VueUse实现&lt;/h2&gt; &lt;div v-bind=&quot;containerProps&quot; class=&quot;viewport&quot;&gt; &lt;div v-bind=&quot;wrapperProps&quot; class=&quot;list&quot;&gt; &lt;div v-for=&quot;item in list&quot; :key=&quot;item.data.id&quot; class=&quot;item&quot;&gt; &#123;&#123; item.data.name &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;// 虚拟列表容器盒子.viewport &#123; box-sizing: border-box; width: 240px; height: 400px; border: solid 1px #000000; // 开启滚动条 overflow-y: auto; // 开启相对定位 position: relative; .list &#123; width: 100%; height: auto; // 搭配使用绝对定位 position: absolute; top: 0; left: 0; .item &#123; box-sizing: border-box; width: 100%; height: 40px; display: flex; justify-content: center; align-items: center; // 隔行变色 &amp;:nth-child(even) &#123; background: #c7edcc; &#125; &amp;:nth-child(odd) &#123; background: pink; &#125; &#125; &#125;&#125;&lt;/style&gt; vue-virtual-scroller 组件安装依赖 1pnpm install vue-virtual-scroller@next 进阶用法：https://github.com/Akryum/vue-virtual-scroller 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;script setup lang=&quot;ts&quot;&gt;import axios from &#x27;axios&#x27;import &#123; onMounted, ref &#125; from &#x27;vue&#x27;// https://github.com/Akryum/vue-virtual-scrollerimport &#123; RecycleScroller &#125; from &#x27;vue-virtual-scroller&#x27;import &#x27;vue-virtual-scroller/dist/vue-virtual-scroller.css&#x27;type Item = &#123; id: number name: string&#125;// 所有的数据，比如这个数组存放了十万条数据const allListData = ref&lt;Item[]&gt;([])// 获取十万条数据const getData = async () =&gt; &#123; const res = await axios.get(&#x27;http://localhost:3000/large-data&#x27;) allListData.value = res.data.data&#125;// 初始化加载onMounted(() =&gt; &#123; getData()&#125;)// 每一项的高度，比如 40 像素const itemHeight = ref(40)&lt;/script&gt;&lt;template&gt; &lt;h2&gt;虚拟列表-vue-virtual-scroller实现&lt;/h2&gt; &lt;RecycleScroller class=&quot;viewport&quot; :items=&quot;allListData&quot; :item-size=&quot;itemHeight&quot; key-field=&quot;id&quot; v-slot=&quot;&#123; item &#125;&quot; item-class=&quot;item&quot; &gt; &#123;&#123; item.name &#125;&#125; &lt;/RecycleScroller&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;// 虚拟列表容器盒子.viewport &#123; box-sizing: border-box; width: 240px; height: 400px; border: solid 1px #000000; // 开启滚动条 overflow-y: auto; // 开启相对定位 position: relative; :deep(.item) &#123; box-sizing: border-box; width: 100%; height: 40px; display: flex; justify-content: center; align-items: center; // 隔行变色 &amp;:nth-child(even) &#123; background: #c7edcc; &#125; &amp;:nth-child(odd) &#123; background: pink; &#125; &#125;&#125;&lt;/style&gt; 总结虚拟列表是一种优化大数据量列表渲染性能的技术。其本质是只渲染当前可见区域内的列表项，而不是全部渲染。当用户滚动列表时，虚拟列表会动态计算当前可见区域内需要渲染的列表项，并只渲染这些列表项，从而提高渲染效率。 虚拟列表的实现原理一般是通过计算容器的高度和每个列表项的高度，来确定当前可见区域内需要渲染的列表项数量和位置。 虚拟列表实现原理 VueUse 实现简单需求 vue-virtual-scroller 组件实现复杂需求 应用场景 虚拟列表技术在大数据量列表渲染场景中应用广泛，例如电商商品列表、社交动态列表等。 拓展阅读 VueUse useVirtualList 15.5k vue-virtual-scroller 8.1k 掘金 高性能渲染十万条数据(虚拟列表) 后端一次给你 10 万条数据，如何优雅展示，到底考察我什么?","tags":["vueUse","js","虚拟渲染"],"categories":["知识技能"]},{"title":"ChatGPT 的打字效果原理","path":"/2023/06/08/ChatGPT 的打字效果原理/","content":"前言当下圈内比较火的非 ChatGPT 莫属了。 相信使用过 ChatGPT 的朋友，都会看到，当你提问一个问题时，ChatGPT 会一字一字地给你展示出来，而不是一次性给你返回，如下图： 这样做的好处，我想应该是节省性能吧，并且应该也是因为 AI 需要一边学习，一边把学习到的结果返回到前端，所以需要这样持续输出。 演示环境 电脑 - Windows 10 Node - v16.15.0 Npm - 9.4.0 Express - 4.18.2 请求分析大部分人会联想到 WebSocket，因为它能做到跟前端建立长连接，不断向前端输送东西。 但当我们打开 Network 界面，看到用的不是 WebSocket，而是 EventSource。 服务器发送事件 服务器发送事件 (Server-Sent Events)常用于 Web 页面推送数据和信息。 而 EventSource 接口是 web 内容与服务器发送事件通信的接口。 一个 EventSource 实例会对 HTTP 服务器开启一个持久化的连接，以 text/event-stream 格式发送事件，此连接会一直保持开启直到通过调用 EventSource.close() 关闭。 与 WebSocket 不同的是，服务器发送事件是单向的。数据信息只能从服务端到发送到客户端（如用户的浏览器）。 初级版本 - EventSource接下来带大家来简单实现以下吧！ 后端服务 npm init 初始化项目 安装项目依赖 npm i express cors。 添加响应头：&#39;Content-Type&#39;: &#39;text/event-stream&#39; 以下为参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const express = require(&#x27;express&#x27;)const cors = require(&#x27;cors&#x27;)// 主机const host = &#x27;http://localhost&#x27;// 端口const port = 3000// 创建 express 实例const app = express()// 允许跨域app.use(cors())// 返回的内容const article = `当有人拒绝你时，不要对此感到个人冒犯。假设他们和你一样：忙碌，占据，分心。你只要稍后再请求一次。你会惊讶地发现第二次尝试通常会奏效。`// 路由接口app.get(&#x27;/chat_typing&#x27;, (req, res) =&gt; &#123; // 开启 Server-sent events res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/event-stream&#x27;) let index = 0 let timerId = 0 // 模拟每隔 0.1s 向前端推送一次 timerId = setInterval(() =&gt; &#123; // 获取文字 const data = article[index] console.log(data) // 下标累加 index++ // 响应结果 if (data) &#123; // data：表示数据内容， 表示结尾。 res.write(`data: $&#123;data&#125; `) &#125; else &#123; res.end() clearInterval(timerId) &#125; &#125;, 100)&#125;)// 启动服务器app.listen(port, () =&gt; &#123; console.log(`服务器启动成功 $&#123;host&#125;:$&#123;port&#125;`)&#125;) 前端通过 EventSource 实现，以下为参考代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;// 文章内容const article = ref(&#x27;&#x27;)// 是否连接const isConnect = ref(false)// EventSourcelet source: EventSource// 建立 SSE 连接const connectSSE = () =&gt; &#123; isConnect.value = true // 创建实例 source = new EventSource(&#x27;http://localhost:3000/chat_typing&#x27;) // 接收信息 source.addEventListener(&#x27;message&#x27;, (e) =&gt; &#123; console.log(e) // 判断end，关闭连接 if (e.data === &#x27;end&#x27;) &#123; closeSSE() &#125; // 实时输出字符串 article.value += e.data &#125;)&#125;// 关闭 SSE 连接const closeSSE = () =&gt; &#123; isConnect.value = false source.close()&#125;&lt;/script&gt;&lt;template&gt; &lt;h1&gt;ChatGPT打字效果 - EventSource&lt;/h1&gt; &lt;button :disabled=&quot;isConnect&quot; @click=&quot;connectSSE()&quot;&gt;建立 SSE 连接&lt;/button&gt; &lt;button :disabled=&quot;!isConnect&quot; @click=&quot;closeSSE()&quot;&gt;关闭 SSE 连接&lt;/button&gt; &lt;div class=&quot;box&quot;&gt; &#123;&#123; article &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.box &#123; width: 300px; height: 300px; background-color: pink; border: 1px solid #f00;&#125;&lt;/style&gt; 思考 axios 无法发送 EventSource 或 WebScoket 的请求，是因为 axios 基于哪个对象封装的？ 进阶版本 - fetch使用 EventSource 很方便，但并不完美，有以下的局限性： 只能发送 GET 请求，传参受限 无法设置请求头 ChatGPT 其实是使用的 fetch 实现的，满足更复杂的需求，接下来就来看看 fetch 是如何实现的。 后端 后端调整为了 POST 请求，可接收更多数据 通过 app.use(express.json()) 解析请求体的 JSON 数据 通过 req.body 获取解析后的请求体数据 res.write(data) 可自定义返回内容格式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const express = require(&#x27;express&#x27;)const cors = require(&#x27;cors&#x27;)// 主机const host = &#x27;http://localhost&#x27;// 端口const port = 3000// 创建 express 实例const app = express()// 允许跨域app.use(cors())// 返回的内容const article = `当有人拒绝你时，不要对此感到个人冒犯。假设他们和你一样：忙碌，占据，分心。你只要稍后再请求一次。你会惊讶地发现第二次尝试通常会奏效。`// 解析请求体的 JSON 数据到 req.bodyapp.use(express.json())// 路由接口 POSTapp.post(&#x27;/chat_typing_fetch&#x27;, (req, res) =&gt; &#123; console.log(&#x27;前端参数--&gt;&#x27;, req.body) // 开启 Server-sent events res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/event-stream&#x27;) let index = 0 let timerId = 0 // 模拟每隔 0.1s 向前端推送一次 timerId = setInterval(() =&gt; &#123; // 获取文字 const data = article[index] console.log(data) // 下标累加 index++ // 响应结果 if (data) &#123; res.write(data) &#125; else &#123; res.end() clearInterval(timerId) &#125; &#125;, 100) // 断开连接 res.on(&#x27;close&#x27;, () =&gt; &#123; res.end() clearInterval(timerId) &#125;)&#125;) 前端 通过 fetch 发送 POST 请求并传参 通过 AbortController 中断请求 通过 TextDecoder 解码文本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;// 存储文章内容const article = ref(&#x27;&#x27;)// 表示是否连接 SSEconst isConnect = ref(false)// 请求中止控制器let controller: AbortController// 建立 SSE 连接const connectSSE = async () =&gt; &#123; // 将 isConnect 设置为 true，表示正在连接 SSE isConnect.value = true // 创建一个新的请求中止控制器 controller = new AbortController() // 发送 POST 请求到服务器 const res = await fetch(&#x27;http://localhost:3000/chat_typing_fetch&#x27;, &#123; // 请求中止标识 signal: controller.signal, // 使用 POST 方法发送请求 method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27;, &#125;, body: JSON.stringify(&#123; user: &#x27;itheima&#x27; &#125;), &#125;) // 获取响应内容的 ReadableStream const reader = res.body?.getReader() // 创建一个解码器，用来解码文本 const decoder = new TextDecoder() while (reader) &#123; // 读取响应内容 const &#123; done, value &#125; = await reader.read() if (done) &#123; // 如果请求已经完成，中止请求 closeSSE() // 退出循环 break &#125; // 将解码后的文本添加到文章内容中 article.value += decoder.decode(value) &#125;&#125;// 关闭 SSE 连接const closeSSE = () =&gt; &#123; // 将 isConnect 设置为 false，表示已经关闭 SSE 连接 isConnect.value = false // 中止请求 controller.abort()&#125;&lt;/script&gt;&lt;template&gt; &lt;h1&gt;ChatGPT打字效果 - fetch &amp; POST&lt;/h1&gt; &lt;button :disabled=&quot;isConnect&quot; @click=&quot;connectSSE()&quot;&gt;建立 SSE 连接&lt;/button&gt; &lt;button :disabled=&quot;!isConnect&quot; @click=&quot;closeSSE()&quot;&gt;关闭 SSE 连接&lt;/button&gt; &lt;div class=&quot;box&quot;&gt; &#123;&#123; article &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;.box &#123; width: 300px; height: 300px; background-color: pink; border: 1px solid #f00;&#125;&lt;/style&gt; 总结SSE 是一种由服务器向浏览器实时主动推送数据的技术，ChatGPT 的打字机效果的原理其实就是通过 SSE 技术实现的。 由于并不是传统请求，使用时需前后端共同配合实现 后端: 需添加响应头：&#39;Content-Type&#39;: &#39;text/event-stream&#39; 前端: 通过 EventSource 或 fetch 实现请求 拓展阅读 服务器发送事件 EventSource 使用 Fetch ChatGPT 掘金热门文章 如果想快速部署一个私人 ChatGPT 网站，不受访问限制，可参考以下开源仓库。 ChatGPT-Next-Web 官方 30.8k Vercel 部署教程","tags":["js","EventSource"],"categories":["知识技能"]},{"path":"/wiki/index.html","content":"暂无项目"}]